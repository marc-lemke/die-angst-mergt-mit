{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>\"Die Angst mergt mit.\"</p> <p>-- ein GitHub-User, 2023</p> <p>Alle kennen Git. Und alle wissen, w\u00e4hrend sie die f\u00fcnfte <code>_final</code>-Endung an den Dateinamen anpappen: m\u00fcssten wir eigentlich benutzen. Und sie denken: Aber versteht irgendjemand dieses Tool wirklich? Wollen wir unsere Projektdaten wirklich dieser Black Box anvertrauen? Und wer will eigentlich diese ganzen Befehle auswendig lernen? ... Und so schicken sie schlie\u00dflich schnell, halb seufzend, halb zufrieden, die E-Mail mit der <code>project_overview_final_final2_final3_final4_final5.docx</code> im Anhang ab.</p> <p>Wenn ihr euch jetzt angesprochen f\u00fchlt, seid ihr hier richtig. Und wenn ihr Git eine Chance geben wollt. Dann gibt es die gute Nachricht gleich zu Beginn: Eure Projektdaten sind sicher. Das ist ein wesentliches Feature dieses Tools. Anstatt einfach nur Dateien und Ordner zu speichern, werden Ordner-Zust\u00e4nde protokolliert. Wie das genau funktioniert und welche best practices es gibt, davon werdet ihr hier einen konkreten Eindruck bekommen.</p> <p>Die Idee ist: Probiert es aus! Ob ihr zum ersten Mal Git installiert oder schon etwas Erfahrung mitbringt - hier bekommt ihr eine kollaborative Experimentalumgebung, in der ihr Dinge testen k\u00f6nnt. Da Git ein Kommandozeilen-Tool ist, werden auch wir darin arbeiten. Unten am Ende von Experiment #1 findet ihr Hinweise auf Tools mit grafischer Benutzeroberfl\u00e4che, die in der t\u00e4glichen Arbeit mit Git viel Zeit und Aufwand sparen. Aber um das Tool zu verstehen, hilft es ungemein, die Befehle und ihre Anwendung in der Praxis der Kommandozeile zu sehen. Sie auswendig zu lernen ist also am Ende des Tages nicht n\u00f6tig: Einerseits lautet die Empfehlung, sp\u00e4ter in der t\u00e4glichen Arbeit auf die besagten Tools mit grafischer Benutzeroberfl\u00e4che zur\u00fcckzugreifen. Und Andererseits findet ihr hier sogenannte Cheat Sheets, in denen die wichtigsten Befehle \u00fcbersichtlich aufgelistet sind.</p> <p>Ende der Vorrede.</p>"},{"location":"cheat-sheets/","title":"Cheat Sheets (und die offizielle Dokumentation)","text":"<ul> <li>interaktive \u00dcbersicht \u00fcber die Bereiche eines Repos und die dazugeh\u00f6rigen Befehle</li> <li>das git-Cheat Sheet von GitLab</li> <li>das git-Cheat Sheet von GitHub</li> <li>die offizielle git-Dokumentation</li> </ul>"},{"location":"cheat-sheets/#die-angst-mergt-mit-cheat-sheet","title":"\"Die Angst mergt mit\"-Cheat Sheet","text":"Was wir tun Befehle Kommentar Repo untersuchen <code>git status</code>"},{"location":"getting-started/","title":"Getting started","text":"<p>Dieses Tutorial ist eine do it yourself-Anleitung: Hier baut ihr euch lokal eine Struktur aus drei Repositorien auf, die die \u00fcbliche Arbeitssituation mit Online-Repositorien simuliert. Wenn ihr an diesem Punkt euch fragt, wovon ich \u00fcberhaupt rede: Keine Sorge, eine aufeinander aufbauende Erl\u00e4uterung von Git-Begriffen findet ihr im Abschnitt Was ist ...?. Aber zu Beginn: Folgt einfach ersteinmal der Anleitung Schritt f\u00fcr Schritt und erstellt die Experimentalumgebung.</p> <ul> <li>Installiert euch Git f\u00fcr euer Betriebssystem auf eurem Rechner.</li> <li>\u00d6ffnet ein Terminal mit Kommandozeile (Git Bash in Windows) und testet die Git-Installation: <code>git --version</code> sollte eine Versionsnummer ausgeben.</li> <li>Erzeugt einen Tutorial-Ordner irgendwo auf eurem System und \u00f6ffnet diesen Ordner im Terminal.</li> <li>Initialisiert dort ein blankes (englisch: bare) Repository: <code>git init --bare an-online-repo.git</code>.</li> <li>Erzeugt zwei weitere Ordner im Tutorial-Ordner: <code>userA</code> und <code>userB</code>.</li> <li>Wechselt im Terminal in einen der User-Ordner und klont das \"Online\"-Repo dort hinein: <code>git clone ../an-online-repo.git</code>.</li> <li>Wiederholt den vorigen Schritt im anderen User-Ordner.</li> <li>Wechselt im Terminal in einen der durch Klonen erzeugten Repo-Ordner <code>/an-online-repo</code>.</li> <li>Erzeugt dort eine neue Datei: <code>echo # Dies ist eine Readme-Datei&gt;readme.md</code>.</li> <li>Erzeugt einen ersten Commit: <code>git add readme.md</code> und <code>git commit -m \"erster Commit\"</code>.</li> <li>Pusht den Commit (und damit auch den Master-Branch) in das \"Online\"-Repo: <code>git push</code>.</li> <li>Wechselt im Terminal in den anderen durch Klonen erzeugten Repo-Ordner <code>/an-online-repo</code>.</li> <li>Pullt dort die neusten \u00c4nderungen, also den Master-Branch mit dem ersten Commit: <code>git pull</code>.</li> <li>Finaler Check: In beiden Ordner <code>UserA/an-online-repo/</code> und <code>UserB/an-online-repo/</code> sollte nun die Datei <code>readme.md</code> liegen.</li> </ul> <p>Gl\u00fcckwunsch! Jetzt habt ihr lokal die Situation hergestellt, die beim kollaborativen Arbeiten mit Online-Repositorien \u00fcblich ist: Es gibt ein blankes Online-Repositorium, auf das mehrere User mit lokalen Repositorien zugreifen.</p> <p></p> <p>Um die User A und B in der History der Repos zuk\u00fcnftig besser zu unterscheiden, wechselt nun im Terminal noch nacheinander in die geklonten Repos und gebt Namen und E-Mail-Adressen der User ein. Diese Einstellungen gelten nur jeweils f\u00fcr das Repository:</p> <pre><code>cd Tutorial-Ordner/UserA/an-online-repo\ngit config --local user.name \"UserA\"\ngit config --local user.email \"UserA@example.com\"\n\ncd Tutorial-Ordner/UserB/an-online-repo\ngit config --local user.name \"UserB\"\ngit config --local user.email \"UserB@example.com\"\n</code></pre> <p>Von hier ab k\u00f6nnt ihr selbst in der Testumgebung experimentieren.</p> <p>Als Hilfestellung und Inspiration findet ihr im Folgenden: - einen Was ist ...?-Abschnitt, der f\u00fcr Einsteiger und Fortgeschrittene die Git-Begriffe und -Funktionsweise erkl\u00e4rt, - eine Liste mit Cheat Sheets und der offiziellen Git-Dokumentation, mit der ihr git-Befehle nachschlagen k\u00f6nnt, - und eine Liste mit Experimentalanleitungen zu verschiedenen Themen.</p> <p>Gute Einstiegspunkte sind der Was ist ...?-Abschnitt und Experiment #1.</p> <p>Have fun!</p>"},{"location":"was-ist/","title":"Was ist ... ?","text":""},{"location":"was-ist/#git","title":"... Git?","text":"<p>Git ist ein Versionierungssystem f\u00fcr Dateien in einem Ordner, das zum kollaborativen Arbeiten geeignet ist, aber auch f\u00fcr die Versionierung lokaler Ordner. Anstatt verschiedene Versionen einer Datei h\u00e4ndisch etwa durch Dateinamen wie <code>meine_Datei_12februar.xml</code>, <code>meine_Datei_13februar.xml</code>, <code>meine_Datei_13februar_korrigiert.xml</code> und <code>meine_Datei_13februar_korrigiert_final.xml</code> zu unterscheiden, kann man mit Git die Datei zusammen mit ihrer Entwicklung speichern - und zwar so, dass man jeglichen fr\u00fcheren Zustand sp\u00e4ter wiederherstellen kann, wenn man das m\u00f6chte. Die \u00c4nderungen an der Datei werden bei jedem Eingriff protokolliert: Es wird also, selbst man eine Datei l\u00f6scht, nie wirklich etwas unwiderbringlich gel\u00f6scht, sondern die L\u00f6schung wird lediglich protokolliert.</p>"},{"location":"was-ist/#ein-repository","title":"... ein Repository?","text":"<p>Zentrale Organisationseinheit f\u00fcr Git ist das Repository: der versionierte Ordner mit seiner gesamten History. In einem \u00fcblichen, nicht-blanken Repository liegt diese Geschichte und die gesamte Logik des Repos in dem versteckten Ordner <code>.git</code>. Schaut einmal selbst nach: In den Repo-Ordnern von UserA und UserB (<code>/an-online-repo</code>) k\u00f6nnt ihr dieses Verzeichnis finden. Falls ihr es in Windows mit dem Datei-Explorer nicht seht, achtet darauf unter Ansicht das H\u00e4kchen bei Ausgeblendete Elemente zu setzen.</p> <p>Da die gesamte Logik im <code>.git</code>-Ordner liegt, bedeutet das auch: Um ein Repo zu l\u00f6schen, muss nur dieser Ordner gel\u00f6scht werden. Um ein Repo zu kopieren, kann der <code>.git</code>-Ordner in einen anderen Ordner kopiert werden. Es wird weiterhin wie gewohnt funktionieren. Der Punkt ist: Mit der Installation von Git auf einem System wird keine zentrale Registry oder dergleichen angelegt, von der aus alle Repos verwaltet werden w\u00fcrden. Jedes Repository ist stattdessen f\u00fcr sich autark.</p>"},{"location":"was-ist/#ein-bare-repository","title":"... ein bare-Repository?","text":"<p>Blanke Repositorien sind daf\u00fcr gedacht, nur ein Zugriffspunkt zum Teilen von Daten zu sein. Sie besitzen daher keinen Working Tree (Arbeitsordner) und keine Verkn\u00fcpfung zu einem anderen, einem Remote-Repository. Sie sind eben selbst reine Remote-Repositorien, die \u00fcblicherweise online gespeichert werden. Schaut euch im Vergleich zu den User-Repos nun unser lokales Remote-Repo <code>an-online-repo.git</code> im Tutorial-Ordner an: Ihr k\u00f6nnt diese \"Datei\" im Terminal oder im Datei-Explorer wie einen Ordner betreten.</p>"},{"location":"was-ist/#der-working-tree","title":"... der Working Tree?","text":"<p>Der Working Tree ist der Ordner, in dem der User in einem herk\u00f6mmlichen lokalen Repository arbeitet: Hier werden die Dateien des Repos gem\u00e4\u00df des aktuellen Repo-Zustandes angezeigt. Denn: Entgegen des herk\u00f6mmlichen Verst\u00e4ndnisses von Ordnern und Dateien (n\u00e4mlich dass es fragile Elemente sind, die auf Nimmerwiedersehen fort sind, wenn man sie l\u00f6scht) funktioniert der Working Tree wie eine Ansicht: Die eigentliche Speicherung der Daten passiert im versteckten <code>.git</code>-Ordner und je nachdem, welchen Zustand der Daten man sich anschauen m\u00f6chte, werden die entsprechenden Daten im Working Tree dann angezeigt. L\u00f6scht man eine Datei im Working Tree, ist sie damit also nicht aus dem Repository gel\u00f6scht.</p> <p>Der Working Tree ist aber nicht nur ein Ort zum Ansehen von Daten, sondern auch, um Ver\u00e4nderungen an den Daten in das Repo zu speichern. \u00c4nderungen sind also immer eine Hinzuf\u00fcgung von Informationen, nichts geht verloren. Was der User zum Speichern von \u00c4nderungen tun muss, ist, einen Commit vorzubereiten und durchzuf\u00fchren.</p>"},{"location":"was-ist/#ein-commit","title":"... ein Commit?","text":"<p>Ein Commit ist ein Snapshot, ein Abbild des Zustandes des Working Trees (genauer gesagt: einer Auswahl der Dateien aus dem Working Tree, des Index) zu einem bestimmten Zeitpunkt: Er beinhaltet Dateien in Form von Blobs, die Ordnerstruktur als Tree sowie Meta-Daten zum Commit (Zeitpunkt des Commits, Username, Kommentar). Das hei\u00dft, dass Git mit einem Commit nicht nur die \u00c4nderungen zu einem fr\u00fcheren Zeitpunkt oder einzelne Dateien speichert, sondern jeweils immer den gesamten Zustand. Probiert es aus: Wechselt im Terminal in eines der User-Repos <code>/an-online-repo</code> und gebt <code>git ls-tree --full-tree -r HEAD</code> ein. Dies listet euch alle Dateien des letzten Commits inklusive Unterordner auf. Wenn ihr noch keinen zweiten Commit angefertigt habt, tut es jetzt: <code>echo # Dies ist eine zweite Readme-Datei&gt;another_readme.md</code>, <code>git add another_readme.md</code> und <code>git commit -m \"eine zweite Readme hinzugef\u00fcgt\"</code>. Jetzt gebt noch einmal <code>git ls-tree --full-tree -r HEAD</code>, um euch die Dateien des neuesten Commits anzuschauen: Darin befinden sich beide Readme-Dateien.</p> <p>Grunds\u00e4tzlich bedeutet das also: Wenn eine Datei in einem bestimmten Zustand in irgendeinem Commit gespeichert wurde, kann man diese Datei in diesem bestimmten Zustand jederzeit wieder anzeigen lassen, egal wie der Working Tree im Moment auch aussehen mag. Entscheidend ist, dass die entsprechenden Commits, die die Datei in diesem bestimmten Zustand enthalten, in der History des Repos existieren und nicht gel\u00f6scht wurden. An dieser Stelle kann schon gesagt werden: Es ist best practice, vergangene Commits nicht zu entfernen, sondern stattdessen unerw\u00fcnschte \u00c4nderungen durch einen weiteren Commit \"r\u00fcckg\u00e4ngig\" zu machen. (Dazu dient <code>git revert</code>, mehr dazu siehe unten: Experiment #7: Fehler r\u00fcckg\u00e4ngig machen)</p>"},{"location":"was-ist/#ein-blob","title":"... ein Blob?","text":"<p>Blob (binary large object) ist die Bezeichnung f\u00fcr die git-interne Art und Weise, Dateien in einem Commit zu speichern.</p>"},{"location":"was-ist/#ein-tree","title":"... ein Tree?","text":"<p>Tree ist ein Begriff f\u00fcr Ordner. Der Working Tree ist der Ordner, in dem der User arbeitet. Mit jedem Commit wird auch immer mindestens ein Tree-Objekt gespeichert, n\u00e4mlich jenes, das alle Dateien (Blobs) und sonstige Ordner (Trees) des Commits enth\u00e4lt und mit <code>git ls-tree</code> angeschaut werden kann.</p>"},{"location":"was-ist/#tracking","title":"... Tracking?","text":"<p>Ver\u00e4ndert sich etwas im Working Tree, erkennt Git das: Dateien k\u00f6nnen in diesem Moment als neu (bisher ungetrackt) oder modifziert (bereits getrackt, aber eben ver\u00e4ndert) markiert werden. Tracking meint im eigentlichen und engeren Sinn den Vorgang, die Ver\u00e4nderungen in Dateien zu \u00fcberwachen, die bereits Teil des letzten Commits waren. Dar\u00fcberhinaus wird von Git aber auch erkannt, wenn v\u00f6llig neue Dateien im Working Tree sich befinden, was man auch als eine Form von Tracking im weiteren Sinn verstehen kann.</p> <p>M\u00f6chte man letzteres f\u00fcr bestimmte Dateien und Ordner verhindern, kann im Working Tree die Datei <code>.gitignore</code> angelegt werden, die eine Liste der Dateien und Ordner enth\u00e4lt, die vom Tracking im weiten Sinne ausgeschlossen werden sollen. So kann man Elemente im Working Tree haben, die nicht zum Repo geh\u00f6ren sollen, etwa sensible Daten.</p> <p>Ist jedoch eine Datei bereits Teil des letzten Commits, reicht die Aufnahme in die <code>.gitignore</code>-Liste nicht aus. Dann muss die betreffende Datei noch zus\u00e4tzlich mittels <code>git rm --cached &lt;Dateiname&gt;</code> aus dem Tracking des Repos (genauer: aus dem Index) entfernt werden.</p>"},{"location":"was-ist/#staging-und-der-index","title":"... Staging und der Index?","text":"<p>Zwischen dem Working Tree und der History des Repos mit seinen Commits gibt es noch einen \u00dcbergangsbereich: die staging area oder den Index. Hier wird der zuk\u00fcnftige Commit zusammengestellt. Der Index enth\u00e4lt ersteinmal alle Dateien und Ordner des letzten Commits in dem Zustand, in dem sie sich zum Zeitpunkt des letzten Commits befanden. Wenn aber nun eine Datei, die Teil des letzten Commits war, ver\u00e4ndert wird, ist sie in diesem neuen Zustand nicht mehr Teil des Index. Die Datei muss in ihrem neuen Zustand also ersteinmal wieder zum Index hinzugef\u00fcgt, also gestaged werden, m\u00f6chte man sie in den zuk\u00fcnftigen Commit \u00fcbernehmen: <code>git add &lt;filename&gt;</code>. Das Gleiche gilt f\u00fcr v\u00f6llig neue Dateien.</p> <p>Ist der gew\u00fcnschte Commit im Index schlie\u00dflich wie gew\u00fcnscht vorbereitet (\u00fcberpr\u00fcfbar mit <code>git status</code> oder <code>git diff --name-only --cached</code>, beides zeigt die Ver\u00e4nderungen im Vergleich zum letzten Commit), kann dieser erzeugt und zur History hinzugef\u00fcgt werden: <code>git commit -m \"ein beliebiger Kommentar zum Commit\"</code>.</p>"},{"location":"was-ist/#ein-branch","title":"... ein Branch?","text":"<p>Mit Branch (Ast, Abzweigung) wird eine Reihe von zusammengeh\u00f6rigen Commits bezeichnet, deren Ausgangspunkt (oder Basis) ein bestimmter Commit in der History ist. Mit dem allerersten Commit im Repo wird der erste, standardm\u00e4\u00dfig <code>master</code> genannte Branch, er\u00f6ffnet. Ab diesem Zeitpunkt k\u00f6nnen beliebig viele weitere Branches erzeugt werden, die den ersten Commit oder einen zu einem sp\u00e4teren Zeitpunkt erzeugten Commit als Basis verwenden. Die Abbildung zeigt ein Beispiel mit zeitlichem Ablauf: Nachdem auf dem <code>master</code>-Branch die Commits C1 und C2 erzeugt worden sind, wurde auf Basis von C1 ein zweiter Branch <code>feature</code> gestartet und der Commit C3 auf diesem Branch gespeichert. </p> <p></p> <p>\u00dcblicherweise ist immer ein Branch ausgecheckt. Das bedeutet, er ist aktiv. Das wiederum hei\u00dft zum Einen: Zuk\u00fcnftige Commits werden diesem aktuell ausgecheckten Branch zugeordnet. Und zum Anderen: Im Working Tree sind dann entsprechend die Dateien und Datei-Versionen zu sehen, die zum j\u00fcngsten Commit des aktuell ausgecheckten Branches geh\u00f6ren. Der g\u00e4ngige Befehl zum Aktivieren eines Branches lautet <code>git checkout &lt;branchname&gt;</code>.</p> <p>Branches sind damit ein M\u00f6glichkeit, parallel verschiedene Ansichten des Repos zur Verf\u00fcgung zu haben: Wechselt man den Branch, wechselt auch die Ansicht im Working Tree. Man sagt auch: Der HEAD zeigt auf einen bestimmten Branch.</p>"},{"location":"was-ist/#head","title":"... HEAD?","text":"<p>HEAD ist eigentlich nur ein Verweis, ein Zeiger, der aber dar\u00fcber bestimmt, welche Daten aktuell im Working Tree angezeigt werden und ob kommende Commits einem Branch bzw. welchem Branch zugeordnet werden. HEAD zeigt \u00fcblicherweise auf den aktuell ausgecheckten Branch. Gebt einmal in einem der User-Repos <code>git show</code> ein: Wenn ihr gerade auf dem <code>master</code>-Branch seid, ist in der ersten Zeile der nun angezeigten Nachricht die Information <code>HEAD -&gt; master</code> zu sehen. Der <code>master</code>-Branch ist also gerade aktiv. Es ist jedoch auch m\u00f6glich, einen bestimmten Commit auszuchecken.</p> <p></p> <p>Dann hat das Repo einen sogenannten detached HEAD: Es ist dann auf keinen Branch mehr eingestellt und zuk\u00fcnftige Commits werden dadurch keinem existierenden Branch mehr zugeordnet. Solche zuk\u00fcnftigen Commits im \"luftleeren\" bzw. branchleeren Raum existieren also au\u00dferhalb der History und gehen in dem Moment verloren, wenn wieder einer der breits bestehenden Branches aktiviert wird. M\u00f6chte man diese Commits aber doch behalten, kann man f\u00fcr sie einfach einen neuen Branch er\u00f6ffnen - mit dem aktuell ausgecheckten Commit als Basis. Die zuvor branchlosen Commits sind dann automatisch Teil des neuen Branches.</p> <p>Wof\u00fcr ist das gut? Mit einem detached HEAD zu arbeiten und einen bestimmten Commit auszuchecken, ist genau das Feature, was Git zu einem n\u00fctzlichen Tool macht: Es bietet die M\u00f6glichkeit, einen bestimmten vergangenen Zustand des Repos im Working Tree anzuschauen. Das ist n\u00fctzlich. Man muss jedoch auch immer im Auge behalten, ob man sich gerade auf einem Branch befindet bzw. auf welchem Branch. Mit <code>git status</code> kann schnell gepr\u00fcft werden, ob man im Moment einen detached HEAD hat.</p> <p>Um einen Commit auszuchecken, braucht man zuvor dessen Hash-Wert: Gebt einmal <code>git log</code> in einem der lokalen Repos ein und werdet f\u00fcr jeden Commit eine lange Reihe an Buchstaben und Zahlen sehen. Das ist ein Hash-Wert, der als ID f\u00fcr den Commit fungiert. F\u00fcr den checkout-Befehl reicht es aus, die ersten Zeichen dieses Hash-Wertes zu verwenden, sofern es nicht mehrere Commits in der History gibt, deren Hash-Wert mit den gleichen Zeichen beginnen: <code>git checkout 9ffe98</code> w\u00fcrde bei einem Hash-Wert von <code>9ffe980b31a28a9ce2795a1756e87172af48fb24</code> sehr wahrscheinlich gen\u00fcgen.</p> <p><code>git log</code> kann eventuell eine l\u00e4ngere Liste an Commits anzeigen. Im Terminal wird diese Liste wom\u00f6glich in Abschnitten angezeigt. Mit <code>Leerzeichen</code> k\u00f6nnt ihr zum n\u00e4chsten Abschnitt wechseln und mit <code>Q</code> die Listenansicht verlassen.</p>"},{"location":"was-ist/#mergen","title":"... mergen?","text":"<p>Mergen (verschmelzen) ist ein Algorithmus, der zwei Versionen eines Branches (lokal und remote) oder zwei verschiedene Branches (etwa <code>master</code> und einen zweiten Branch) zusammenzuf\u00fchrt. Ersteres ist etwa n\u00f6tig, wenn mehrere User auf einem Branch arbeiten: UserA macht einen Commit A und pusht ihn. W\u00e4hrenddessen hat UserB lokal bei sich einen anderen Commit B erzeugt, ohne vorher Commit A gefetcht zu haben. Um den Branch danach f\u00fcr alle User auf einen Stand zu bringen, der Commit A und B gleicherma\u00dfen enth\u00e4lt, m\u00fcssen beide Versionen des Branches in einen Commit C gemergt werden. Analog funktioniert es im zweiten Fall, wie in der Grafik zu sehen: Der <code>feature</code>-Branch enth\u00e4lt einen Commit C3, der im <code>master</code> unbekannt ist. Hier wird nun vom <code>master</code> aus gesehen der <code>feature</code>-Branch in den <code>master</code> gemergt, was bedeutet, dass die \u00c4nderungen von C3 zusammen mit den \u00c4nderungen von C4 (der letzte Commit vor dem Merge) im neuen Commit C5 auf dem <code>master</code>-Branch zusammengebracht werden.</p> <p></p> <p>Merkmal des Mergens ist in allen F\u00e4llen, dass ein neuer Commit erzeugt wird, der alle \u00c4nderungen aus den letzten Commits der beiden beteiligten Branches oder Branch-Versionen beinhaltet. Dabei kann es zu Konflikten kommen, die Git entweder automatisch selbst l\u00f6st oder die der User l\u00f6sen muss, indem er etwa Dateien, in denen sich \u00c4nderungen aus den beteiligten Commits widersprechen, h\u00e4ndisch bearbeitet, anschlie\u00dfend speichert und den Merge-Vorgang fortsetzt. Wie das genau funktioniert, k\u00f6nnt ihr im Experiment zu Merge-Konflikten untersuchen.</p>"},{"location":"was-ist/#die-history","title":"... die History?","text":"<p>Mit History ist die gesamgte Abfolge von Commits, Branch-Er\u00f6ffnungen und -Schlie\u00dfungen eines Repos gemeint, eben dessen Geschichte, die alle vergangenen Zust\u00e4nde der in den Commits gespeicherten Dateien und Ordner enth\u00e4lt.</p>"},{"location":"was-ist/#ein-remote-repository","title":"... ein Remote-Repository?","text":"<p>In einer Beziehung zwischen lokalem und blanken Remote-Repository ist letzteres das Repository, auf das mit mehreren lokalen Repositorien zugegriffen werden kann. Daf\u00fcr haben lokale Repositorien ein Verkn\u00fcpfung mit ihrem Remote, die \u00fcblicherweise <code>origin</code> hei\u00dft, aber auch unbenannt werden kann. <code>origin</code> ist schlicht ein Alias f\u00fcr eine Pfadangabe. Ein lokales Repo kann sogar Verweise zu mehreren Remotes besitzen, was es etwa erlaubt, \u00c4nderungen direkt an mehrere Remote-Repositorien zu schicken.</p> <p>Schaut in einem eurer lokalen Repos einmal nach, welche Remote-Pfade vorhanden sind: <code>git remote -v</code>. Zudem k\u00f6nnt ihr euch die Details zu jedem Remote-Pfad anschauen, etwa zu <code>origin</code>: <code>git remote show origin</code>. Die Fetch- und Push-URLs (also die Ziel-URL f\u00fcr Hoch- und Runterladen von \u00c4nderungen zu einem Remote-Repo) sehen in unserem Tutorial-Setup etwas merkw\u00fcrdig aus, beispielsweise: <code>C:/repositories/git_tutorial/UserB/..\\an-online-repo.git</code>. Dies kommt durch den Pfad zustande, den wir oben zum Klonen des Remote-Repos verwendet haben. Die zwei Punkte im Pfad bedeuten, in den Parent-Ordner <code>git_tutorial</code> zu wechseln, wo sich das Remote-Repo ja befindet. Im Normalfall der Arbeit mit einem Online-Remote-Repository steckt hinter <code>origin</code> eine Web-URL zu einer <code>.git</code>-Datei.</p> <p>Wichtig ist: Insgesamt sorgt die Struktur mit lokalen und Remote-Repositorien daf\u00fcr, dass es immer zwei Versionen des Repos gibt, n\u00e4mlich das lokale und das Remote-Repo. Jeder lokale Branch hat also immer ein Remote-Gegen\u00fcber, sofern man den lokalen Branch im Remote-Repo ver\u00f6ffentlicht hat. Mit <code>git branch -avv</code> werden alle lokalen Branches und die Verweise auf die bekannten Remote-Branches angezeigt, letztere \u00fcblicherweise in Pfadschreibweise: <code>remotes/origin/master</code> ist der Name f\u00fcr den Master-Branch des Remote-Repositories und <code>master</code> ist euer lokaler Master-Branch.</p> <p>Die Befehle <code>git fetch</code>, <code>git pull</code> und <code>git push</code> dienen zur Kommunikation mit dem Remote-Repo: <code>fetch</code> l\u00e4dt die neuesten \u00c4nderungen vom Remote herunter, ohne sie auf das lokale Repo anzuwenden. <code>pull</code> f\u00fcgt die \u00c4nderungen im aktuell aktiven Branch mittels merge ein. Und <code>push</code> l\u00e4dt neue Commits im aktiven lokalen Branch (bzw. sogar den ganzen Branch, falls dieser im Remote noch unbekannt ist) in das Remote-Repo hoch. Im Experiment #1 kann der Umgang mit den Befehlen sich genauer angeschaut werden.</p>"},{"location":"was-ist/#stashen","title":"... stashen?","text":"<p>Hat man \u00c4nderungen am Working Tree vorgenommen und vielleicht auch einige davon schon gestaged, m\u00f6chte diese \u00c4nderungen aber noch nicht committen, bietet <code>git stash push</code> die M\u00f6glichkeit, die \u00c4nderungen zu verbergen und in einer Art Zwischenspeicher abzulegen. Das ist der Stash (Versteck).</p> <p>Es ist ein sehr n\u00fctzliches Feature von Git, falls man zwischendurch in seiner Arbeit am Repo einmal den Branch wechseln m\u00f6chte. In diesem Fall w\u00fcrden die nicht committeten \u00c4nderungen am Working Tree und am Index in dem Moment verloren gehen, wenn man auf einen anderen bereits existierenden Branch mittels <code>git checkout</code> wechselt. Mit dem Stash kann man das Problem umgehen und zu einem sp\u00e4teren Zeitpunkt die \u00c4nderungen wieder hervorholen. Wie das genau funktioniert, ist in einem der Experimente unten erl\u00e4utert.</p>"},{"location":"was-ist/#ein-tag","title":"... ein Tag?","text":"<p>Ein Tag ist ein Verweis auf einen bestimmten Commit. Tags k\u00f6nnen individuell benannt werden und sind also letztlich Aliase, die auch als Parameter des <code>git checkout</code>-Befehls funktionieren, um diesen bestimmten Commit auszuchecken, auf den der Tag verweist. In der Praxis werden Tags h\u00e4ufig zum Markieren von Release-Versionen des Codes bzw. der Daten des Repos verwendet, beispielweise <code>v1.0</code>. Um sich diese Version im Code dann anzuschauen, kann der Commit via Tag ausgecheckt werden: <code>git checkout v1.0</code>.</p>"},{"location":"was-ist/#github-und-gitlab","title":"... GitHub und GitLab?","text":"<p>GitHub und GitLab sind Beispiele f\u00fcr Hosting- und Management-Plattformen f\u00fcr Git-Repositorien. Sie bieten Git-Funktionalit\u00e4ten und \u00fcber Git hinausgehende Tools zum kollaborativen Arbeiten hinter einer grafischen Benutzeroberfl\u00e4che an. \u00c4nderungen am Online-Repo k\u00f6nnen dort direkt im Browser vorgenommen werden: Dateien hinzuf\u00fcgen, l\u00f6schen, \u00e4ndern, Branches erstellen, mergen und entfernen. Es ist jedoch auch m\u00f6glich, ganz ohne die Websites \u00fcber lokale Klone mit den GitHub- und GitLab-Repositorien zu arbeiten. In speziellen Situationen ist das mitunter sogar gew\u00fcnscht, da die Implementierungen von Git auf den Plattformen in ihrem Verhalten davon abweichen k\u00f6nnen, wie Git sich normalerweise verhalten w\u00fcrde (Beispiel).</p>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/","title":"1. Ein einfacher kollaborativer Git-Workflow","text":"<p>Willkommen bei Experiment #1! Hier lernst du konkrete Schritte und Routinen kennen, die \u00fcblicherweise in kollaborativen Projekten mit Git anfallen. Das Setup entspricht der Konstellation, die du bereits auf deinem Rechner lokal erzeugt hast: Es gibt ein Online-Repo, auf das mehrere User des Projekts mit lokalen Klonen zugreifen. Die konkreten Arbeitsweisen mit Git h\u00e4ngen nat\u00fcrlich auch immer vom Arbeitsmaterial und den Zielen des Projekts ab. Im Folgenden findest du daher zwei exemplarische Projekt-Szenarien: den Aufbau eines Text-Korpus und die Entwicklung einer Website.</p> <p>In den Szenarien werden Git-Befehle im Terminal verwendet. Am Ende dieses Experiments stelle ich aber auch noch Tools mit grafischen Benutzeroberfl\u00e4chen vor, die in der t\u00e4glichen Arbeit mit Git verwendet werden k\u00f6nnen: das Git Client Add-On f\u00fcr den Oxygen XML Editor, den Code-Editor VSCode mit der Git Graph-Extension und die Software GitHub Desktop.</p>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#szenario-a-text-korpus","title":"Szenario A: Text-Korpus","text":"<p>Das Projekt-Team will ein Text-Korpus aufbauen und ver\u00f6ffentlichen, es fallen mehrere Aufgaben an: Textquellen ausfindig machen, Texte ausw\u00e4hlen, ein Dateiformat und Textschema f\u00fcr das Korpus definieren, Texte in das gew\u00e4hlte Schema bringen und die Arbeit sowie das Korpus dokumentieren.</p> <p>F\u00fcr das Repo bedeutet das, dass es verschiedene Arten von Dateien gibt: - Texte im Quellformat - Texte im Projektformat - Transformationsskripte - Textschema - Dokumentationsdateien</p> <p>UserA und UserB entscheiden sich daf\u00fcr, die Aufgaben aufzuteilen: UserA sucht Texte im Quellformat, l\u00e4dt sie hoch und dokumentiert das Projekt, UserB schreibt Transformationsskripte und erzeugt die Texte im Projektformat. Beide zusammen arbeiten am Textschema und \u00fcberpr\u00fcfen die transformierten Texte auf Fehler.</p> <p>Wenn die Projektgruppe sehr klein ist und die Aufgaben so verteilt sind, dass es kaum dazu kommt, dass mehrere User die selben Dateien editieren, ist es kein Problem, wenn alle Beteiligten auf dem selben Branch arbeiten: Es wird selten zu Merge-Konflikten kommen. Da man aber plant, das Korpus wie eine Software versioniert zu ver\u00f6ffentlichen, soll das Repo zwei Branches haben: einen Arbeitsbranch und einen, auf dem nur die fertigen Releases gespeichert werden. Unabh\u00e4ngig der Gepflogenheit, den <code>master</code> f\u00fcr Releases zu nutzen und nebenbei einen <code>develop</code>-Branch f\u00fcr die t\u00e4gliche Arbeit zu haben, werden sie auf dem <code>master</code> arbeiten und f\u00fcr die Ver\u00f6ffentlichungen den Branch <code>releases</code> einrichten: Der <code>master</code> ist in Git kein besonderer Branch, sondern nur eine Benennungskonvention.</p> User Aufgabe Ordner/Dateien UserA Texte im Quellformat suchen und hochladen /sources Dokumentation anlegen und pflegen /docs + readme.md UserB Transformationsskripte schreiben /scripts Texte im Projektformat erzeugen /corpus beide Textschema definieren /scheme Korrekturlesen der Texte /corpus <p> Jetzt im Terminal in das Repo von UserA wechseln</p> <p>UserA hat einen Quelltext gefunden und will ihn zusammen mit einer angefangenen Liste der f\u00fcr das Projekt ausgew\u00e4hlten Texte f\u00fcr die Dokumentation hochladen. Davor aber folgt er einer t\u00e4glichen Routine:</p> <pre><code>## pr\u00fcfen, auf welchem Branch man sich lokal befindet\ngit status\n\n## lokalen Branch auf master wechseln, falls n\u00f6tig\ngit checkout master\n\n## die neuesten Daten vom Remote-Branch herunterladen und direkt in den lokalen Branch einf\u00fcgen\ngit pull\n</code></pre> <p>Er legt nun die Ordner <code>/sources</code> und <code>/docs</code> sowie die Dateien <code>text001.txt</code> und <code>textList.csv</code> an. Wir benutzen Dummy-Dateien. Du kannst sie im Explorer oder im Terminal erzeugen:</p> <pre><code>mkdir \"sources\"\ncd sources\necho Lorem Ipsum&gt;text001.txt\ncd ..\n\nmkdir \"docs\"\ncd docs\necho Text,Quelldatei,Quelle&gt;textList.csv\necho Text001,text001.txt,Projekt Gutenberg&gt;&gt;textList.csv\ncd ..\n</code></pre> <p>UserA will die \u00c4nderungen nun stagen, commiten und in das Remote-Repo hochladen. Dabei entscheidet er sich daf\u00fcr, zwei Commits daraus zu machen, da die vorgenommenen \u00c4nderungen zwei unterschiedliche Aufgabenbereiche betreffen: Quelltextablage und Dokumentation. Das hat in der Zukunft einen m\u00f6glichen Vorteil: Entscheidet man sich sp\u00e4ter daf\u00fcr, Text001 doch nicht in das Korpus aufzunehmen, kann man dann gezielt den einen Commit r\u00fcckg\u00e4ngig machen, mit dem die txt-Datei hinzugef\u00fcgt wurde, ohne zugleich auch die <code>textList.csv</code> mit entfernen zu m\u00fcssen.</p> <p>\u00dcbrigens: Mit \"einen Commit r\u00fcckg\u00e4ngig machen\" ist nicht l\u00f6schen gemeint, sondern das Erzeugen eines neuen Commits, der die \u00c4nderungen des alten Commits mittels <code>git revert</code> r\u00fcckg\u00e4ngig macht. Mehr dazu findet ihr im Experiment #7. Nun weiter im Text.</p> <pre><code>## schauen, welche Ver\u00e4nderungen im Working Tree erkannt worden sind\ngit status\ngit ls-files --others\n\n## den Text stagen, um ihn zum Commit vorzubereiten\ngit add sources/text001.txt\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"Text001-Quelltext hinzugef\u00fcgt\"\n\n## die Textliste stagen\ngit add docs/textList.csv\n\n## den zweiten Commit erzeugen\ngit commit -m \"Textliste hinzugef\u00fcgt\"\n\n## die Commits in das Remote-Repo pushen\ngit push\n</code></pre> <p> Jetzt im Terminal in das Repo von UserB wechseln.</p> <p>UserB beginnt danach einen Entwurf f\u00fcr das Textschema zu entwerfen und l\u00e4dt das Dokument hoch. Wie gehabt, folgt auch er zuvor der vereinbarten Routine:</p> <pre><code>## pr\u00fcfen, auf welchem Branch man sich lokal befindet\ngit status\n\n## (Hinweis: Da an dieser Stelle UserB noch keine Updates vom Remote-Repo geholt hat, steht in der Status-Meldung \"Your branch is up to date with 'origin/master'\". Die Meldung aktualisiert sich erst nach einem fetch. Verwendet man zum Updaten dagegen pull, werden die \u00c4nderungen direkt in den lokalen Branch gemergt, was bewirkt, dass eine anschlie\u00dfende status-Anfrage wiederum ergibt, dass der lokale Branch uptodate ist, was er dann ja auch tats\u00e4chlich ist. Zusammengefasst: Der status-Befehl macht keine eigene Abfrage, sondern vergleicht den lokalen Branch mit der zuletzt gefetchten Version des Remote-Branches.)\n\n## lokalen Branch auf master wechseln, falls n\u00f6tig\ngit checkout master\n\n## die neuesten Daten vom Remote-Branch herunterladen und direkt in den lokalen Branch einf\u00fcgen\ngit pull\n\n## (UserB sieht nun die Text-Datei und Text-Liste, die UserA gepusht hat.)\n</code></pre> <p>Dummy-Datei anlegen:</p> <pre><code>mkdir \"scheme\"\ncd scheme\necho a scheme file&gt;project.odd\ncd ..\n</code></pre> <p>Stagen, committen und pushen:</p> <pre><code>## schauen, welche Ver\u00e4nderungen im Working Tree erkannt worden sind\ngit status\ngit ls-files --others\n\n## den Text stagen, um ihn zum Commit vorzubereiten\ngit add scheme/project.odd\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"erste Version des Schemas hinzugef\u00fcgt\"\n\n## die Commits in das Remote-Repo pushen\ngit push\n</code></pre> <p> Jetzt im Terminal wieder in das Repo von UserA wechseln.</p> <p>UserA m\u00f6chte nun weitere Quelltexte hinzuf\u00fcgen, <code>textList.csv</code> aktualisieren und eine erste Version der <code>readme.md</code> des Repos hochladen. Diesmal aber vergisst er die Routine und pullt nicht den aktuellen Stand des Remote-Repos. Mal schauen, was passiert. Zun\u00e4chst legen wir wieder die Dummy-Dateien an und aktualisieren <code>textList.csv</code> sowie <code>readme.md</code>. Im Code entferne ich hier die alte <code>readme.md</code> und f\u00fcge eine neue ein. F\u00fcr Git ist dies jedoch eine Aktualisierung, da der Dateiname der gleiche ist. Ihr k\u00f6nnt die \u00c4nderungen wie gehabt im Datei-Explorer oder im Terminal durchf\u00fchren.</p> <pre><code>cd sources\necho Lorem Ipsum zum Zweiten&gt;text002.txt\necho Lorem Ipsum zum Dritten&gt;text003.txt\ncd ..\n\ncd docs\necho Text002,text002.txt,Projekt Gutenberg&gt;&gt;textList.csv\necho Text003,text003.txt,DTA&gt;&gt;textList.csv\ncd ..\n\nrm -f readme.md\necho # Projekt-Korpus&gt;readme.md\n</code></pre> <p>Wiederum entscheidet UserA nun, drei Commits aus dem \u00c4nderungen zu machen: einen f\u00fcr die Quelltexte, einen f\u00fcr die Aktualisierung der <code>textList.csv</code> und einen f\u00fcr die Aktualisierung der <code>readme.md</code>:</p> <pre><code>## schauen, welche Ver\u00e4nderungen im Working Tree erkannt worden sind\ngit status\ngit ls-files --others\ngit ls-files --modified\n\n## die Texte stagen, alle \u00c4nderungen im Order \"/sources\"\ngit add sources\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"Quelltexte 2 und 3 hinzugef\u00fcgt\"\n\n## die aktualisierte Textliste stagen, auch als Abk\u00fcrzung den Ordner \"/docs\", da wir alle ge\u00e4nderten Dateien in \"/docs\" stagen wollen, auch wenn es nur eine ist\ngit add docs\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"Texte 2 und 3 zur Textliste hinzugef\u00fcgt\"\n\n## die aktualisierte readme.md stagen\ngit add readme.md\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"Entwurf f\u00fcr ernsthafte Repo-Readme\"\n</code></pre> <p>Nun zum interessanten Teil: <code>git status</code> w\u00fcrde an diesem Punkt die Nachricht <code>Your branch is ahead of 'origin/master' by 3 commits</code> ausgeben. Jedoch hat UserA bekanntlich vergessen, sich den aktuellen Stand vom Remote-Repo zu holen. Er versucht jetzt, seine \u00c4nderungen zu pushen, und bekommt folgende Meldung:</p> <pre><code> ! [rejected]        master -&gt; master (fetch first)\nerror: failed to push some refs to 'D:/repositories/git_tutorial/UserA/..\\an-online-repo.git'\nhint: Updates were rejected because the remote contains work that you do not\nhint: have locally. This is usually caused by another repository pushing to\nhint: the same ref. If you want to integrate the remote changes, use\nhint: 'git pull' before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n</code></pre> <p>Mit <code>git push</code> werden die Wissensst\u00e4nde der Repos (lokal und Remote) miteinander verglichen: Dadurch wurde nun erkannt, dass inzwischen UserB Commits zum Master-Branch des Remote-Repos hinzugef\u00fcgt hat. Vollautomatisch wird die Situation von Git nicht aufgel\u00f6st, da die Kontrolle in diesen F\u00e4llen beim User liegen soll.</p> <p>Die L\u00f6sung f\u00fcr das Problem ist, mit <code>git pull</code> sich den neuesten Stand zu ziehen und lokal diesen Stand mit dem lokalen Stand zu mergen. Das hei\u00dft, dass lokal ein neuer Commit erzeugt wird, der den Stand des letzten eigenen lokalen Commits mit dem des letzten Commits aus dem Remote-Repo auf dem <code>master</code>-Branch verbindet. Dieses Vorgehen ist n\u00f6tig, um zu pr\u00fcfen, ob die \u00c4nderungen von UserA und UserB miteinander kompatibel sind. In diesem Fall ist dieser Merge unproblematisch, da beide User an unterschiedlichen Dateien gearbeiten haben. Versuchen wir es:</p> <pre><code>## den neuesten Stand des Remote-Master-Branches ziehen und versuchen, mit dem lokalen Branch zu mergen\ngit pull\n\n## der Vorgang wird abgebrochen und wir bekommen als Antwort die Aufforderung, zu entscheiden, mit welcher Methode Git in so einem Fall die Branches auf einen Stand bringen soll\nhint: You have divergent branches and need to specify how to reconcile them.\nhint: You can do so by running one of the following commands sometime before\nhint: your next pull:\nhint:\nhint:   git config pull.rebase false  # merge\nhint:   git config pull.rebase true   # rebase\nhint:   git config pull.ff only       # fast-forward only\nhint:\nhint: You can replace \"git config\" with \"git config --global\" to set a default\nhint: preference for all repositories. You can also pass --rebase, --no-rebase,\nhint: or --ff-only on the command line to override the configured default per\nhint: invocation.\nfatal: Need to specify how to reconcile divergent branches.\n</code></pre> <p>Wir entscheiden uns f\u00fcr <code>merge</code>. <code>rebase</code> ist ein Verfahren, dass im Gegensatz zu <code>merge</code> keinen neuen Commit erzeugt, sondern lokal die Commits von UserB in die eigene History so einf\u00fcgt, dass es so aussieht, als h\u00e4tte UserA vor seinen eigenen Commits sich doch den aktuellen Stand des Remote-Repos via <code>git pull</code> geholt. <code>rebase</code> ver\u00e4ndert also die History des Repos. F\u00fcr diesen lokalen Anwendungsfall hier ist das kein Problem und es k\u00f6nnen <code>merge</code> und <code>rebase</code> gleicherma\u00dfen genutzt werden. <code>rebase</code> ist dagegen problematisch, wenn es direkt im Remote-Repo angewendet wird und mehrere User mit dem betroffenen Branch arbeiten: Ihre lokalen und Remote-Branches unterscheiden sich dann pl\u00f6tzlich und es hagelt Fehlermeldungen. Zuletzt noch zur dritten genannten Option <code>fast-forward only</code>: Sie w\u00fcrde unser Problem nicht l\u00f6sen, da Fast-Forward genau den optimalen Fall meint, dass mein lokaler Branch keine dem Remote unbekannten Commits besitzt.</p> <p>Wir entscheiden uns also f\u00fcr <code>merge</code>, stellen das in der Repo-Konfiguration ein und versuchen erneut, mit <code>git pull</code> die unterschiedlichen Commits von UserA und UserB lokal in einem Commit auf <code>master</code> zu verbinden. Wir schauen uns das Ergebnis im Log grafisch an und pushen das Ergebnis.</p> <pre><code>## pull-Methode einstellen\ngit config pull.rebase false\n\n## pull-Versuch wiederholen, es sollte nun automatisch ein neuer Commit erzeugt werden\ngit pull\n\n## die Commit-Liste mit grafischer Repr\u00e4sentation der zweitweise unterschiedlichen Branch-Zust\u00e4nde ansehen\ngit log --graph\n\n## (Wir k\u00f6nnen hier den \u00fcblichen Kommentar eines Commits sehen, der von Git mit pull automatisch erzeugt worden ist: \"Merge branch 'master' of &lt;REPO&gt;\". Und wir k\u00f6nnen sehen, dass der Commit von UserB nun auch als Verweis in unser lokalen Commit-History auftaucht.)\n## (\"git log\" kann eventuell eine l\u00e4ngere Liste an Commits anzeigen. Im Terminal wird diese Liste wom\u00f6glich in Abschnitten angezeigt. Mit \"Leerzeichen\" k\u00f6nnt ihr zum n\u00e4chsten Abschnitt wechseln und mit \"Q\" die Listenansicht verlassen.)\n\n## Repo-Status anschauen: Unser lokaler Branch ist nun 4 Commits weiter als der Remote-Branch - mit den drei eigenen Commits und dem, der durch den pull-Befehl erzeugt worden ist\ngit status\n\n## pushen\ngit push\n</code></pre> <p>Voil\u00e1, UserA hat das Problem gel\u00f6st. Vor dem Committen den neuesten Stand zu pullen, h\u00e4tte die Situation zwar verhindert. Aber Git als kollaboratives Versionierungstool bietet M\u00f6glichkeiten, mit solchen unterschiedlichen Zust\u00e4nden von lokalem und Remote-Branch umzugehen. Daf\u00fcr ist es gedacht. Das sehen wir jetzt auch im letzten Abschnitt dieses Szenarios.</p> <p> Im Terminal in das Repo von UserB wechseln.</p> <p>UserB seinerseits vergisst nun auch, sich zu Beginn seiner Arbeit am Repo den neuesten Stand vom Remote herunterzuladen. Entgegen der abgesprochenen Aufteilung der Aufgaben m\u00f6chte er spontan f\u00fcr die <code>readme.md</code> des Repos einen ersten Vorschlag zum Projekt beisteuern.</p> <pre><code>## Dummy-Datei mit anderer \u00dcberschrift anlegen, als UserA in seiner Version verwendet hat\nrm -f readme.md\necho # Korpus&gt;readme.md\n</code></pre> <p>UserB staged die \u00c4nderung, erzeugt einen Commit und versucht ihn zu pushen.</p> <pre><code>## die readme.md stagen\ngit add readme.md\n\n## \u00fcberpr\u00fcfen, welche Dateien f\u00fcr den folgenden Commit gestaged sind\ngit status\ngit diff --name-only --cached\n\n## committen\ngit commit -m \"Projekt-Readme-Entwurf\"\n\n## pushen\ngit push\n</code></pre> <p>UserB wird zu\u00e4chst wie UserA auch aufgefordert zu entscheiden, mit welcher Methode <code>git pull</code> verschiedene Branch-Zust\u00e4nde zwischen lokalem und Remote-Branch vereinen soll. UserB entscheidet sich f\u00fcr <code>merge</code> und versucht erneut zu pullen.</p> <pre><code>## pull-Methode einstellen\ngit config pull.rebase false\n\n## pull-Versuch wiederholen\ngit pull\n</code></pre> <p>Im Gegensatz zur Situation von UserA kann Git hier die Commits von lokalem und Remote-Branch nicht einfach verbinden, denn UserA und UserB haben jeweils die erste Zeile der <code>readme.md</code> ver\u00e4ndert. Git kann somit nicht entscheiden, welche Version die gew\u00fcnschte ist, und \u00fcbergibt die Entscheidung dem User:</p> <pre><code>Auto-merging readme.md\nCONFLICT (content): Merge conflict in readme.md\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>Um den Konflikt manuell zu l\u00f6sen, muss UserA die <code>readme.md</code> in seinem Working Tree mit einem Text- oder Code-Editor \u00f6ffnen. Dort f\u00e4llt auf, dass Git den Inhalt der Datei ver\u00e4ndert hat:</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n# Korpus\n=======\n# Projekt-Korpus\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; 54a0706feaab2da3789b2693320a7fb5fea5afcb\n</code></pre> <p>Die Schreibweise markiert hier, wo der Konflikt sich befindet und welche Version der ersten Zeile des Dokuments von welchem Repo kommt: <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> markiert den Beginn des Konflikts. Die folgenden Zeilen bis <code>=======</code> sind die Version des sogenannten Basis- oder Head-Branches, also des Branches, der das Ziel der Merge-Prozedur ist - in diesem Fall ist das die Version von UserB auf seinem lokalen <code>master</code>-Branch. Zwischen <code>=======</code> und <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> folgt die Version des Branches, der in den Basis-Branch gemergt werden soll: die Version von UserA aus dem Remote-<code>master</code>.</p> <p>Um den Konflikt zu l\u00f6sen, m\u00fcssen die drei Zeilen mit den von Git gesetzten Steuerzeichen komplett gel\u00f6scht werden. UserB kann sich f\u00fcr eine der Varianten entscheiden oder die Zeile anders schreiben. Am Ende jedenfalls muss die Datei gespeichert, neu gestaged und committet werden. Wenn das f\u00fcr alle Dateien mit manuell zu l\u00f6senden Merge-Konflikten erledigt ist, ist der pull-Vorgang abgeschlossen. Die \u00c4nderungen k\u00f6nnen dann sofort gepusht werden.</p> <pre><code>## stagen nach dem manuellen L\u00f6sen des Konflikts\ngit add readme.md\n\n## commit\ngit commit -m \"Merge-Konflikt gel\u00f6st\"\n\n## zum Testen: einmal pullen - der pull-Vorgang ist jedoch schon abgeschlossen\ngit pull\n\n## pushen\ngit push\n</code></pre> <p>Damit endet dieses kleine Szenario: Neben den t\u00e4glichen Git-Routinen und den h\u00e4ufig verwendeten Git-Befehlen war vor allem zu sehen, wie man bei der kollaborativen Arbeit auf einem Branch mit Merge-Konflikten umgeht. Im zweiten Szenario nun ist die Arbeitsweise eine andere: Hier arbeiten die Beteiligten auf unterschiedlichen Branches und m\u00fcssen diese von Zeit und Zeit wieder auf einen Stand bringen.</p>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#szenario-b-website","title":"Szenario B: Website","text":"<p>Das zweite Projekt-Team entwickelt eine Website. Auch sie richten sich einen <code>releases</code>-Branch ein, um die Commits mit den fertigen Versionen dort zu speichern, und auch hier findet die Entwicklung auf dem <code>master</code> statt. Anders als das Korpus-Team entwickeln aber die Projekt-Mitglieder jeweils einzelne Features (wie eine Such-Funktion oder das Hauptmen\u00fc oder eine Seite auf der Website) auf speziell daf\u00fcr tempor\u00e4r angelegten Branches. Sobald ein Feature fertig ist, wird der Feature-Branch in den <code>master</code> gemergt.</p> <p>Dieses Vorgehen ist bei diesem Projekt sinnvoll, denn auf diese Weise k\u00f6nnen zwischenzeitlich, auch wenn ein Feature noch nicht ganz fertig entwickelt ist, die anderen Projekt-Mitglieder sich die Website schon einmal mit Hauptmen\u00fc oder Such-Funktion anschauen: Daf\u00fcr wechseln sie einfach kurz auf den entsprechenden Feature-Branch, um sich einen Eindruck vom zuk\u00fcnftigen Zustand der Website in ihrem Working Tree zu verschaffen.</p> <p>Falls ihr schon Szenario A durchgespielt habt, gehen wir der Einfachheit halber davon aus, dass das Korpus-Team auch eine Website entwickelt, um die Arbeit im Web zu pr\u00e4sentieren.</p> <p> Im Terminal in das Repo von UserA wechseln.</p> <p>UserA legt in seinem lokalen Repo einen <code>/website</code>-Ordner an, f\u00fcgt eine <code>index.html</code> mit einem Hauptmen\u00fc sowie die dazugeh\u00f6rigen Pages im Ordner <code>/pages</code> hinzu. Schlie\u00dflich staged, committet und pusht er das Ganze als einen initialen Commit.</p> <pre><code>## Ordner und Dateien anlegen\nmkdir \"website\"\ncd website\necho Hauptmenu: Projekt, Korpus, Schema&gt;index.html\nmkdir pages\ncd pages\necho Lorem Ipsum&gt;projekt.html\necho Lorem Ipsum&gt;korpus.html\necho Lorem Ipsum&gt;schema.html\ncd ..\ncd ..\n\n## alle \u00c4nderungen stagen\ngit add --all\n\n## Commit erstellen\ngit commit -m \"Initialer Commit f\u00fcr die Website\"\n\n## Commit hochladen\ngit push\n</code></pre> <p> Im Terminal in das Repo von UserB wechseln.</p> <p>UserB beginnt seine t\u00e4gliche Arbeitsroutine damit, zu pr\u00fcfen, auf welchem Branch er sich befindet, und die neuesten \u00c4nderungen aus dem Remote-Repo in sein lokales Repo einzuf\u00fcgen:</p> <pre><code>## pr\u00fcfen, auf welchem Branch man sich lokal befindet\ngit status\n\n## lokalen Branch auf master wechseln, falls n\u00f6tig\ngit checkout master\n\n## die neuesten Daten vom Remote-Branch herunterladen und direkt in den lokalen Branch einf\u00fcgen\ngit pull\n</code></pre> <p>Mit der Entwicklung einer Suchfunktion betraut, erzeugt UserB nun einen daf\u00fcr gedachten lokalen Branch <code>suchfunktion</code>:</p> <pre><code>## neuen lokalen Branch anlegen: der Basis-Commit dieses neuen Branches ist der letzte Commit des master-Branches, da wir uns gerade auf master befinden\ngit checkout -b suchfunktion\n\n## pr\u00fcfen, auf welchem Branch wir uns jetzt befinden\ngit status\n\n## Liste aller Branches (lokal und remote) anzeigen lassen\ngit branch -avv\n</code></pre> <p>Die \u00dcbersicht \u00fcber die Branches verr\u00e4t, dass es zu <code>suchfunktion</code> noch keinen dazugeh\u00f6rigen Remote-Branch <code>remotes/origin/suchfunktion</code> gibt. Im Moment hat UserB nur einen lokalen Branch angelegt: Dieser wird erst mit <code>git push</code> vom Branch <code>suchfunktion</code> aus ver\u00f6ffentlicht. Prinzipiell kann man Branches als reine Lokal-Branches nutzen: Pushes von anderen lokalen Branches aus ver\u00f6ffentlichen <code>suchfunktion</code> nicht.</p> <p>UserB entwickelt im Folgenden das Feature, staged und committet die \u00c4nderungen und macht seinen Feature-Branch im Remote-Repo f\u00fcr die anderen Projekt-Mitglieder sichtbar:</p> <pre><code>## in index.html den neuen Men\u00fcpunkt \"Suche\" hinzuf\u00fcgen\ncd website\nrm -f index.html\necho Hauptmenu: Projekt, Korpus, Schema, Suche&gt;index.html\n\n## neue Suche-Page hinzuf\u00fcgen\ncd pages\necho Lorem Ipsum&gt;suche.html\ncd ..\ncd ..\n\n## alle \u00c4nderungen stagen\ngit add --all\n\n## Commit erzeugen\ngit commit -m \"Suchfunktion implementiert\"\n\n## Commit und damit auch den Feature-Branch in das Remote-Repo hochladen\ngit push --set-upstream origin suchfunktion\n\n## (Mit der Flag \"--set-upstream origin suchfunktion\" wird die Verkn\u00fcpfung zwischen dem lokalen und dem Remote-Branch \"suchfunktion\" explizit gesetzt. Damit werden in Zukunft \"git push\" und \"git pull\" wissen, woher sie beziehen und wohin sie sie hochladen m\u00fcssen, wenn das lokale Repo sich auf dem \"suchfunktion\"-Branch befindet.)\n\n## Liste aller Branches (lokal und remote) anzeigen lassen\ngit branch -avv\n</code></pre> <p>Nun ist der Branch <code>suchfunktion</code> mit dem Such-Feature ver\u00f6ffentlicht und kann von den Team-Mitgliedern besichtigt werden.</p> <p> Im Terminal in das Repo von UserA wechseln.</p> <p>UserA l\u00e4dt sich den neuen Branch herunter...</p> <pre><code>## den neusten Stand des Remote-Repos herunterladen\ngit pull\n\n## den neuen Branch \"suchfunktion\" auschecken\ngit checkout suchfunktion\n</code></pre> <p>... und testet das neue Feature.</p> <p> Im Terminal in das Repo von UserB wechseln.</p> <p>UserB bekommt gr\u00fcnes Licht. Da alle zufrieden sind, wird entschieden, das Such-Feature so, wie es jetzt ist, in den <code>master</code>-Branch aufzunehmen, also zum festen Bestandteil der Website zu machen. Daf\u00fcr wird der Branch <code>suchfunktion</code> nun in den <code>master</code> gemergt, was bedeutet, dass in <code>master</code> ein neuer Commit erzeugt wird, der den Stand des letzten Commits auf dem <code>suchfunktion</code>-Branch mit dem Stand des letzten <code>master</code>-Commits vereint. Der Branch <code>suchfunktion</code> bleibt dabei, wie er ist.</p> <p>Dieser Vorgang wird in unserem Fall problemlos ablaufen, da seit der Erstellung des <code>suchfunktion</code>-Branches auf dem <code>master</code>-Branch kein neuer Commit hinzugekommen ist: Es ist, als h\u00e4tte UserB die Suchfunktion direkt auf dem <code>master</code> entwickelt. Diese konfliktfreie Art des Mergens nennt man auch Fast-forward.</p> <pre><code>## auf den Branch wechseln, in den die \u00c4nderungen des anderen Branches integriert werden sollen\ngit checkout master\n\n## sicherstellen, dass man die neuesten Commits vom Remote-Master lokal zur Verf\u00fcgung hat\ngit pull\n\n## den lokalen suchfunktion-Branch in den lokalen master-Branch mergen\ngit merge suchfunktion\n</code></pre> <p>Der Merge war erfolgreich, er hat aber lokal stattgefunden. Mit <code>git push</code> wird der neue Zustand des <code>master</code>-Branches nun in das Remote-Repo geladen.</p> <pre><code>## den neuen Zustand vom master pushen\ngit push\n\n## aktuelle Liste der lokalen und Remote-Branches anschauen\ngit branch -avv\n</code></pre> <p>Da das Feature implementiert und von allen Team-Mitgliedern abgenickt ist, hat der Branch <code>suchfunktion</code> seinen Zweck erf\u00fcllt. Um die History und Liste der Branches \u00fcbersichtlich zu halten, ist es \u00fcblich, an dieser Stelle den Feature-Branch zu l\u00f6schen. F\u00fcr zuk\u00fcnftige gr\u00f6\u00dfere \u00c4nderungen an der Website, wie eben die Entwicklung eines neuen Features oder einer neuen Page, werden immer jeweils neue Feature-Branches ins Leben gerufen.</p> <pre><code>## den lokalen Branch \"suchfunktion\" l\u00f6schen\ngit branch -d suchfunktion\n\n## (Hinweis: Dieser Befehl wird scheitern, wenn die Remote-Version und die lokale Version des Branches sich unterscheiden. Um auch in diesem Fall den lokalen Branch zu l\u00f6schen, muss die Flag `-D` verwendet werden: `git branch -D suchfunktion`.)\n\n## den Remote-Branch \"suchfunktion\" l\u00f6schen\ngit push -d origin suchfunktion\n\n## aktuelle Liste der lokalen und Remote-Branches anschauen\ngit branch -avv\n</code></pre> <p> Im Terminal in das Repo von UserA wechseln.</p> <p>UserA will sich einige Zeit sp\u00e4ter nochmal den <code>suchfunktion</code>-Branch anschauen und versucht den neuesten Stand zu pullen, bekommt aber nat\u00fcrlich eine Fehlermeldung, da UserB den Branch im Remote-Repo ja schon gel\u00f6scht hat. UserA schaut verwirrt auf die Branch-Liste, die <code>git branch -avv</code> ihm ausgibt: Da wird <code>remotes/origin/suchfunktion</code> noch als existent angezeigt.</p> <p>Das Problem ist hier, dass ein einfacher <code>git fetch</code>-Befehl nicht ausreicht, um die Liste der lokalen Verkn\u00fcpfungen zu den Remote-Branches zu aktualisieren: Alle anderen User m\u00fcssen, nachdem ein anderer User einen Remote-Branch l\u00f6scht, ihre lokalen Verkn\u00fcpfungen aktualisieren: <code>git fetch --all --prune</code>. Damit werden alle lokalen Verkn\u00fcpfungen zu Remote-Branches, die nicht mehr existieren, entfernt und <code>git branch -avv</code> sollte nun die aktuelle Situation korrekt anzeigen.</p> <p>Davon abgesehen \u00e4ndert UserA noch eine Kleinigkeit in der <code>index.html</code> und im <code>/pages</code>-Ordner: Den Titel der Seite \"Schema\" schreibt er in \"Schemata\" um, da das Projekt eventuell mehrere Schemata publizieren wird. Am Ende staged, committet und pusht er die \u00c4nderungen.</p> <pre><code>## pr\u00fcfen, ob er auf dem master-Branch ist\ngit status\n\n## auf den lokalen master-Branch wechseln, falls n\u00f6tig\ngit checkout master\n\n## index.html \u00e4ndern\ncd website\nrm -f index.html\necho Hauptmenu: Projekt, Korpus, Schemata, Suche&gt;index.html\n\n## Name von schema.html \u00e4ndern\ncd pages\nrm -f schema.html\necho Lorem Ipsum&gt;schemata.html\ncd ..\ncd ..\n\n## stagen\ngit add --all\n\n## committen\ngit commit -m \"Menupunkt 'Schema' in 'Schemata' umbenannt\"\n\n## pushen\ngit push\n</code></pre> <p> Im Terminal in das Repo von UserB wechseln.</p> <p>UserB entwickelt derweil eine Changelog-Seite auf einem neuen Feature-Branch <code>changelog</code>. In unserer fiktiven Timeline hat UserB damit bereits begonnen, bevor UserA seine letzten \u00c4nderungen committet hat. Das hei\u00dft in dieser Situation: UserB hat keine Chance, die letzten \u00c4nderungen von UserA zu pullen, bevor er den neuen Branch <code>changelog</code> er\u00f6ffnet.</p> <pre><code>## pr\u00fcfen, auf welchem Branch wir uns befinden\ngit status\n\n## auf den master-Branch wechseln, falls n\u00f6tig\ngit checkout master\n\n## den aktuellsten Commit auf dem master-Branch anschauen\ngit show HEAD\n\n## (UserB kennt also zu diesem Zeitpunkt den Commit von UserA nicht, mit dem er den Menupunkt \"Schema\" in \"Schemata\" ge\u00e4ndert hat.)\n\n## neuen lokalen Branch anlegen: der Basis-Commit dieses neuen Branches ist der zu diesem Zeitpunkt letzte Commit des master-Branches \"Suchfunktion implementiert\"\ngit checkout -b changelog\n\n## pr\u00fcfen, auf welchem Branch wir uns jetzt befinden\ngit status\n\n## Liste aller Branches (lokal und remote) anzeigen lassen\ngit branch -avv\n\n## in index.html den neuen Men\u00fcpunkt \"Changelog\" hinzuf\u00fcgen\ncd website\nrm -f index.html\necho Hauptmenu: Projekt, Korpus, Schema, Suche, Changelog&gt;index.html\n\n## neue Suche-Page hinzuf\u00fcgen\ncd pages\necho Lorem Ipsum&gt;changelog.html\ncd ..\ncd ..\n\n## alle \u00c4nderungen stagen\ngit add --all\n\n## Commit erzeugen\ngit commit -m \"Changelog implementiert\"\n\n## Commit und damit auch den Feature-Branch in das Remote-Repo hochladen\ngit push --set-upstream origin changelog\n\n## Liste aller Branches (lokal und remote) anzeigen lassen\ngit branch -avv\n</code></pre> <p>Damit ist der <code>changelog</code>-Branch im Remote-Repo ver\u00f6ffentlicht. Auch dieses Feature wird vom Projekt-Team positiv aufgenommen. UserB bekommt erneut gr\u00fcnes Licht zum Mergen des Feature-Branches in den <code>master</code>. </p> <pre><code>## auf den Branch wechseln, in den die \u00c4nderungen des anderen Branches integriert werden sollen\ngit checkout master\n\n## sicherstellen, dass man die neuesten Commits vom Remote-Master lokal zur Verf\u00fcgung hat\ngit pull\n\n## (Hier merkt UserB nun, dass der master-Branch seit dem Erzeugen des changelog-Branches einen neuen Commit erhalten hat. Am urspr\u00fcnglichen Plan, die Branches zu mergen, \u00e4ndert das jedoch nichts: Git bietet die Features an, mit m\u00f6glichen Konflikten zwischen den Commits umzugehen.)\n\n## den lokalen changelog-Branch in den lokalen master-Branch mergen\ngit merge changelog\n</code></pre> <p>UserB bekommt eine Konflikt-Meldung, da UserA und UserB die gleiche Zeile in der gleichen Datei <code>index.html</code> ver\u00e4ndert haben:</p> <pre><code>Auto-merging website/index.html\nCONFLICT (content): Merge conflict in website/index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>Git \u00fcbergibt die Kontrolle dem User. Um den Konflikt manuell zu l\u00f6sen, muss UserB die <code>readme.md</code> in seinem Working Tree mit einem Text- oder Code-Editor \u00f6ffnen. Dort f\u00e4llt erneut auf, dass Git den Inhalt der Datei ver\u00e4ndert hat:</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nHauptmenu: Projekt, Korpus, Schemata, Suche\n=======\nHauptmenu: Projekt, Korpus, Schema, Suche, Changelog\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; changelog\n</code></pre> <p>Die Schreibweise markiert hier, wo der Konflikt sich befindet und welche Version der ersten Zeile des Dokuments von welchem Repo kommt: <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> markiert den Beginn des Konflikts. Die folgenden Zeilen bis <code>=======</code> sind die Version des sogenannten Basis- oder Head-Branches, also des Branches, der das Ziel der Merge-Prozedur ist - in diesem Fall ist das die Version von UserA auf seinem lokalen <code>master</code>-Branch. Zwischen <code>=======</code> und <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> folgt die Version des Branches, der in den Basis-Branch gemergt werden soll: die Version von UserB aus <code>changelog</code>.</p> <p>Um den Konflikt zu l\u00f6sen, m\u00fcssen die drei Zeilen mit den von Git gesetzten Steuerzeichen komplett gel\u00f6scht werden. UserB kann sich f\u00fcr eine der Varianten entscheiden oder die Zeile anders schreiben. Die L\u00f6sung hier ist <code>Hauptmenu: Projekt, Korpus, Schemata, Suche, Changelog</code>. Am Ende muss die Datei gespeichert, neu gestaged und committet werden. Wenn das f\u00fcr alle Dateien mit manuell zu l\u00f6senden Merge-Konflikten erledigt ist, ist der <code>merge</code>-Vorgang abgeschlossen. Der aktualisierte lokale <code>master</code> mit dem neuen Merge-Commit kann dann sofort gepusht werden.</p> <pre><code>## stagen nach dem manuellen L\u00f6sen des Konflikts\ngit add index.html\n\n## commit\ngit commit -m \"Merge-Konflikt gel\u00f6st\"\n\n## pr\u00fcfen, ob alle Commits von UserA und UserB nun sich im master-Branch befinden\ngit log\n\n## pushen\ngit push\n\n## aktuelle Liste der lokalen und Remote-Branches anschauen\ngit branch -avv\n</code></pre> <p>Damit ist der Merge abgeschlossen. Schlie\u00dflich l\u00f6scht UserB den Feature-Branch lokal und im Remote-Repository:</p> <pre><code>## den lokalen Branch \"changelog\" l\u00f6schen\ngit branch -d changelog\n\n## (erneut der Hinweis: Dieser Befehl wird scheitern, wenn die Remote-Version und die lokale Version des Branches sich unterscheiden. Um auch in diesem Fall den lokalen Branch zu l\u00f6schen, muss die Flag `-D` verwendet werden: `git branch -D changelog`.)\n\n## den Remote-Branch \"changelog\" l\u00f6schen\ngit push -d origin changelog\n\n## aktuelle Liste der lokalen und Remote-Branches anschauen\ngit branch -avv\n</code></pre> <p>Das ist das Ende des zweiten Szenarios. Es ist zu sehen gewesen, wie die t\u00e4glichen Abl\u00e4ufe im kollaborativen Arbeiten mit Git aussehen, welche Befehle dabei immer wieder zum Einsatz kommen und vor allem: dass ein Konflikt zwischen zwei Versionen einer Datei (in Git-Begriffen: zwischen zwei zu mergenden Commits) kein unbedingt zu verhindernder Ausnahmezustand ist, sondern zum kollaborativen Arbeiten mit Dateien (auch ohne Git) dazugeh\u00f6rt. Git h\u00e4lt gezielt Features daf\u00fcr bereit, mit dieser Situation umzugehen.</p> <p>Diese und die anderen Features m\u00fcssen nicht zwingend \u00fcber die Kommandozeile bedient werden. Im Folgenden stelle ich euch drei Tools mit grafischer Benutzeroberfl\u00e4che vor. Ihr habt bis hier schon viele Befehle kennengelernt (falls noch nicht geschehen: ein Blick in den Was ist ... -Abschnitt ist daf\u00fcr empfohlen). Zu wissen, wie Git auf Ebene der Kommandozeile funktioniert, hilft enorm, die Funktionen dieser Tools zu verstehen.</p>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#tools-fur-die-arbeit-mit-lokalen-repositorien","title":"Tools f\u00fcr die Arbeit mit lokalen Repositorien","text":"<p>Die am h\u00e4ufigsten gebrauchten Git-Befehle zu kennen ist n\u00fctzlich. Im t\u00e4glichen Einsatz beschleunigen Git-Tools mit grafischen Benutzeroberfl\u00e4chen die Arbeit jedoch enorm. Drei von ihnen werden im Folgenden vorgestellt.</p>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#git-client-add-on-fur-oxygen-xml-editor","title":"Git Client Add-On f\u00fcr Oxygen XML Editor","text":"<p>Download</p> <ul> <li>Betriebssysteme: Win / Linux / Mac</li> <li>Plugin f\u00fcr Oxygen XML Editor 24.1 oder neuer</li> <li>f\u00fcr lokale Repos und Repos von allen g\u00e4ngigen Online-Plattformen (GitHub, GitLab) verwendbar</li> </ul>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#visual-studio-code-vscode-mit-git-graph-extension","title":"Visual Studio Code (VSCode) mit Git Graph-Extension","text":"<p>Download</p> <ul> <li>Betriebssysteme: Win / Linux / Mac</li> <li>Code-Editor mit Git-Funktionen</li> <li>f\u00fcr lokale Repos und Repos von allen g\u00e4ngigen Online-Plattformen (GitHub, GitLab) verwendbar</li> </ul>"},{"location":"experimente/1-ein-einfacher-kollaborativer-git-workflow/#github-desktop","title":"GitHub Desktop","text":"<p>Download</p> <ul> <li>Betriebssysteme: Win / Mac</li> <li>Software zum Verwalten von Git-Repositorien</li> <li>f\u00fcr lokale Repos und Repos von allen g\u00e4ngigen Online-Plattformen (GitHub, GitLab) verwendbar</li> </ul>"},{"location":"experimente/10-mit-einem-detached-HEAD-arbeiten/","title":"10. Mit einem detached HEAD arbeiten","text":""},{"location":"experimente/11-mit-mehreren-remote-repositorien-arbeiten/","title":"11. Mit mehreren Remote-Repositorien arbeiten","text":""},{"location":"experimente/12-unterschiede-zwischen-datei-versionen-anzeigen-diff-und-blame/","title":"12. Unterschiede zwischen Datei-Versionen anzeigen (Diff und Blame)","text":""},{"location":"experimente/2-konfigurationen/","title":"2. Konfigurationen","text":""},{"location":"experimente/2-konfigurationen/#generelles","title":"Generelles","text":"<p>Git h\u00e4lt auf verschiedenen Ebenen Konfigurationen in Form von Key-Value-Paaren bereit: lokale, globale und systemweite. Erstere betreffen nur jeweils ein Repository und sind entsprechend auch darin gespeichert. Was dort alles eingestellt ist, k\u00f6nnt ihr euch im Vergleich zwischen einem der User-Repos und unserem \"Online\"-Repo anschauen: <code>git config --local --list</code>. <code>an-online-repo.git</code> k\u00f6nnt ihr im Terminal wie einen Ordner betreten.</p> <p>Zu sehen ist hier, dass der Key <code>core.bare</code> im \"Online\"-Repo den Wert <code>true</code> hat und dass entsprechend nur die User-Repos die Einstellungen <code>remote.origin.url</code>, <code>remote.origin.fetch</code>, <code>branch.master.remote</code> und <code>branch.master.merge</code> besitzen, da das Online-Repo keinen Verweis auf ein Remote-Repo besitzt.</p> <p>Globale Konfigurationen betreffen User-relevante Konfigurationen und systemweite Einstellungen betreffen alle \u00fcbrigen Einstellungen. In der Regel sind das unterschiedliche Einstellungen. Im Falle der User-Daten (<code>user.name</code> und <code>user.email</code>) aber k\u00f6nnen diese Angaben global und lokal existieren: Die lokalen Angaben \u00fcberschreiben dann die globalen. Wenn ihr also einen bestimmten Usernamen und eine bestimmte E-Mail-Adresse f\u00fcr eure Arbeit an allen Repos auf eurem System benutzen wollt, definiert die Werte einmal global. Dann m\u00fcsst ihr sie nicht in jedem Repo neu definieren.</p> <p>Um euch gezielt globale und systemweite Konfigurationen anzugucken, gebt im Terminal (egal in welchem Ordner) ein: <code>git config --global --list</code> und <code>git config --system --list</code>. Um euch alle Konfigurationen in einer Liste anzuschauen, tippt <code>git config --list</code>. Da hier die Geltungsebene f\u00fcr die einzelne Einstellung nicht mehr zu erkennen ist, k\u00f6nnt ihr euch hier auch den Pfad zur entsprechenden Konfigurationsdatei mitanzeigen lassen: <code>git config --list --show-origin</code>.</p>"},{"location":"experimente/2-konfigurationen/#einstellungen-andern","title":"Einstellungen \u00e4ndern","text":"<p>Mit dem Wissen, wo die Konfigurationsdateien zu finden sind, k\u00f6nnt ihr sie nat\u00fcrlich direkt in einem Editor bearbeiten. Um eine neue Einstellung im Terminal zu setzen, etwa auf globaler Ebene euren Usernamen und eure E-Mail-Adresse, tippt:</p> <pre><code>git config --global user.name \"Maria Mustermann\"\ngit config --global user.email \"mm@example.com\"\n</code></pre> <p>Wollt ihr einen Eintrag, etwa f\u00fcr die E-Mail-Adresse, nicht nur \u00fcberschreiben, sondern l\u00f6schen, nutzt: <code>git config --global --unset user.email</code>.</p>"},{"location":"experimente/2-konfigurationen/#notwendige-einstellungen","title":"Notwendige Einstellungen","text":"<p>Zwei Einstellungen sollten in jedem Fall gesetzt und/oder \u00fcberpr\u00fcft werden: - <code>user.name</code> und <code>user.email</code> (lokal oder global): Ohne diese Werte ist es nicht m\u00f6glich, einen Commit zu machen. - <code>core.autocrlf</code> (system): Diese Werte sollte bei Windows-System auf <code>true</code> und bei allen anderen auf <code>input</code> gesetzt sein. Da Windows-System das Ende einer Zeile in Textdateien anders codieren als Linux- und Mac-System, muss beim kollaborativen Arbeiten gew\u00e4hrleistet sein, dass a) in allen Textdateien die gleiche Zeilenend-Codierung verwendet wird und b) dass alle User lokal in ihrem Working Tree die Textdateien f\u00fcr ihr Betriebssystem korrekt angezeigt bekommen. Ansonsten kann es dazu kommen, dass \u00c4nderungen in der Zeilenend-Codierung von Git als \u00c4nderungen in der Datei erkannt und gespeichert werden. Damit wird die History mit belanglosen \u00c4nderungen geflutet.</p>"},{"location":"experimente/3-aliase/","title":"3. Aliase","text":"<p>Git bietet die M\u00f6glichkeit, f\u00fcr git-Befehle Aliase zu definieren. Benutzt man h\u00e4ufiger einen langen Befehl wie <code>git log --oneline --graph --decorate --all</code>, der im Terminal eine kurze Repr\u00e4sentation der Repo-Historie anzeigt, kann man global einen Alias daf\u00fcr anlegen: <code>git config --global alias.lol \"log --oneline --graph --decorate --all\"</code>. Von nun an k\u00f6nnt ihr tippen: <code>git lol</code>.</p>"},{"location":"experimente/4-elemente-im-working-tree-nicht-zur-history-hinzufuegen-muessen-aber-trotzdem-sicher-behalten-gitignore-und-stash/","title":"4. Elemente im Working Tree nicht zur History hinzuf\u00fcgen m\u00fcssen, aber trotzdem sicher behalten (gitignore und stash)","text":""},{"location":"experimente/5-branches-anlegen-pushen-und-loeschen/","title":"5. Branches anlegen, pushen und l\u00f6schen","text":""},{"location":"experimente/6-dateien-vom-index-entfernen/","title":"6. Dateien vom Index entfernen","text":""},{"location":"experimente/7-fehler-rueckgaengig-machen/","title":"7. Fehler r\u00fcckg\u00e4ngig machen","text":""},{"location":"experimente/8-schnelle-uebersicht-ueber-ein-repo-bekommen-history-branches-HEAD/","title":"8. Schnelle \u00dcbersicht \u00fcber ein Repo bekommen (History, Branches, HEAD)","text":""},{"location":"experimente/9-konflikte-beim-mergen/","title":"9. Konflikte beim Mergen","text":""}]}